#!/usr/bin/env python3
"""
insert_common.py

Usage:
    python insert_common.py [path/to/json]

Default path: known_exploited_vulnerabilities.json (in current directory)
"""

import os
import sys
import json
from datetime import datetime
import psycopg2
from psycopg2.extras import Json

# === DB CONFIG - update if needed ===
DB_CONFIG = {
    "host": "localhost",
    "port": 5432,
    "dbname": "Threat-Intelligence-Database-Schema",  # your DB
    "user": "postgres",
    "password": "root@123"
}

# === Helpers ===
def robust_isoparse(s):
    if not s:
        return None
    try:
        # handle trailing Z
        s2 = str(s).strip()
        if s2.endswith("Z"):
            s2 = s2[:-1] + "+00:00"
        # limit microseconds to 6
        if "." in s2:
            parts = s2.split("+", 1) if "+" in s2 else s2.split("-", 1)
            core = parts[0]
            tail = ("+" + parts[1]) if len(parts) == 2 and s2.count("+") else ("-" + parts[1]) if len(parts) == 2 else ""
            if "." in core:
                sec, micro = core.split(".", 1)
                micro = micro[:6].ljust(6, "0")
                core = sec + "." + micro
            s2 = core + tail
        return datetime.fromisoformat(s2)
    except Exception:
        # fallback simple parse tries
        for fmt in ("%Y-%m-%dT%H:%M:%S.%f%z", "%Y-%m-%dT%H:%M:%S%z", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%d"):
            try:
                return datetime.strptime(str(s), fmt)
            except Exception:
                pass
    return None

def generate_external_id(item):
    # prefer canonical fields
    if not isinstance(item, dict):
        return "item-" + str(abs(hash(str(item))) % (10**10))
    for k in ("cveID", "cveId", "id", "external_id", "name", "vulnerabilityName"):
        v = item.get(k)
        if v:
            return str(v)
    # look into nested raw_data or containers
    raw = item.get("raw_data") or item
    if isinstance(raw, dict):
        cmeta = raw.get("cveMetadata") or raw.get("document", {}).get("tracking") or {}
        if isinstance(cmeta, dict) and cmeta.get("cveId"):
            return str(cmeta.get("cveId"))
        # tracking id
        track = raw.get("document", {}).get("tracking", {}) or raw.get("tracking", {})
        if track and track.get("id"):
            return str(track.get("id"))
    return "item-" + str(abs(hash(json.dumps(item, sort_keys=True))) % (10**12))

def extract_description(item):
    # KEV uses shortDescription; other sources use description or notes
    for k in ("shortDescription", "description", "vulnerabilityName", "notes", "summary"):
        v = item.get(k)
        if v and isinstance(v, str) and v.strip():
            return v.strip()
    # try nested containers.cna.descriptions[]
    try:
        for d in (item.get("raw_data", {}) .get("containers", {}).get("cna", {}).get("descriptions", []) or []):
            if d.get("lang") == "en" and d.get("value"):
                return d.get("value")
    except Exception:
        pass
    return "No description available."

def find_cvss_from_anywhere(item):
    """
    Return (score (float or None), vector (str or None), severity (str or None))
    Searches many common shapes: metrics list, cvss dicts, impact.* etc.
    """
    # scan known keys
    def inspect_dict(d):
        if not isinstance(d, dict):
            return None
        # direct cvss
        if "baseScore" in d and ("vectorString" in d or "baseSeverity" in d):
            return (d.get("baseScore"), d.get("vectorString"), d.get("baseSeverity"))
        # cvssV3.x style
        for k in ("cvssV4_0","cvssV3_1","cvssV3_0","cvssV2_0","cvssV4","cvssV3"):
            if k in d and isinstance(d[k], dict):
                dd = d[k]
                return (dd.get("baseScore") or dd.get("baseScoreV3") or dd.get("score"), dd.get("vectorString"), dd.get("baseSeverity"))
        # nested known
        if "cvss" in d and isinstance(d["cvss"], dict):
            dd = d["cvss"]
            return (dd.get("baseScore") or dd.get("score"), dd.get("vectorString"), dd.get("baseSeverity") or dd.get("severity"))
        return None

    # 1) direct top-level
    for key in ("cvss", "cvssScore", "cvss_v3", "impact", "metrics"):
        v = item.get(key)
        if isinstance(v, dict):
            out = inspect_dict(v)
            if out:
                return out
        # sometimes metrics is a list of dicts
        if isinstance(v, list):
            for e in v:
                out = inspect_dict(e)
                if out:
                    return out

    # 2) raw_data nested (NVD/CNA style)
    raw = item.get("raw_data") or item
    # examples: raw["containers"]["cna"]["metrics"] is a list
    try:
        metrics = (raw.get("containers", {}) .get("cna", {}) .get("metrics")) or raw.get("metrics") or []
        if isinstance(metrics, list):
            # prefer highest-version metrics (4.0 -> 3.1 -> 3.0 -> 2.0)
            pref = ["4.0","cvssV4","3.1","3.0","2.0"]
            # try to find cvss objects
            for m in metrics:
                if isinstance(m, dict):
                    # metric object may contain e.g. "cvssV3_1": {...}
                    for subk, subv in m.items():
                        if isinstance(subv, dict):
                            out = inspect_dict(subv)
                            if out:
                                return out
                    # or m may directly be cvssData
                    out = inspect_dict(m)
                    if out:
                        return out
    except Exception:
        pass

    # 3) deep scan for any dict with baseScore
    def deep_search(d):
        if isinstance(d, dict):
            out = inspect_dict(d)
            if out:
                return out
            for val in d.values():
                res = deep_search(val)
                if res:
                    return res
        elif isinstance(d, list):
            for it in d:
                res = deep_search(it)
                if res:
                    return res
        return None
    out = deep_search(raw)
    if out:
        return out

    # 4) fallback: none found
    return (None, None, None)

def extract_cwes(item):
    # CISA uses cwes (list of strings). Other shapes may include weaknesses list
    cwes = []
    if isinstance(item.get("cwes"), list):
        cwes = item.get("cwes")
    else:
        # try raw_data weaknesses
        raw = item.get("raw_data") or item
        try:
            for w in raw.get("weaknesses", []) or []:
                for desc in w.get("description", []):
                    if desc.get("lang") == "en":
                        cwes.append(desc.get("value"))
        except Exception:
            pass
    # normalize strings
    cwe_ids = []
    for c in (cwes or []):
        if isinstance(c, str):
            # extract id if "CWE-123" or "CWE-123 description"
            if "CWE-" in c:
                try:
                    cwe_ids.append(c.split("CWE-")[1].split()[0])
                except Exception:
                    pass
            else:
                cwe_ids.append(c)
    return cwes, cwe_ids

def extract_vendors_products(item):
    # KEV has vendorProject and product
    vendors = []
    products = []
    if item.get("vendorProject"):
        vendors.append(item.get("vendorProject"))
    if item.get("product"):
        products.append(item.get("product"))
    # also check raw_data.product_tree branches (CNA style)
    raw = item.get("raw_data") or item
    try:
        def rec_branches(branches):
            for b in branches or []:
                if b.get("category") == "vendor" and b.get("name"):
                    vendors.append(b.get("name"))
                if b.get("category") == "product_name" and b.get("name"):
                    products.append(b.get("name"))
                if b.get("branches"):
                    rec_branches(b.get("branches"))
        rec_branches(raw.get("product_tree", {}).get("branches", []))
    except Exception:
        pass
    # dedupe order preserving
    def dedupe(seq):
        out = []
        for x in seq:
            if x not in out:
                out.append(x)
        return out
    return dedupe(vendors), dedupe(products)

def extract_references_and_urls(item):
    refs = []
    # notes often contains semicolon-separated links in KEV
    for k in ("notes", "references", "reference", "notesAndReferences", "urls"):
        v = item.get(k)
        if isinstance(v, list):
            refs.extend([x for x in v if isinstance(x, str) and x.strip()])
        elif isinstance(v, str):
            # split by semicolon or newline
            parts = [p.strip() for p in v.replace("\n",";").split(";") if p.strip()]
            refs.extend(parts)
    # also try raw nested refs
    raw = item.get("raw_data") or item
    try:
        for r in raw.get("references", []) or []:
            if isinstance(r, dict):
                url = r.get("url") or r.get("link") or r.get("summary")
                if url:
                    refs.append(url)
            elif isinstance(r, str):
                refs.append(r)
    except Exception:
        pass
    # dedupe
    refs = list(dict.fromkeys(refs))
    # build actual/original urls
    cveid = item.get("cveID") or item.get("cveId") or None
    original = None
    actual = None
    if cveid:
        original = f"https://nvd.nist.gov/vuln/detail/{cveid}"
        actual = f"https://www.cisa.gov/known-exploited-vulnerabilities/{cveid}"
    # prefer any found direct original/actual fields
    original = item.get("original_source_url") or item.get("originalUrl") or original
    actual = item.get("actual_url") or item.get("actualUrl") or actual
    return refs, len(refs), original, actual

# === Main insertion function ===
def insert_from_json(json_path):
    if not os.path.exists(json_path):
        print(f"❌ File not found: {json_path}")
        return

    # load JSON
    try:
        with open(json_path, "r", encoding="utf-8") as fh:
            payload = json.load(fh)
    except Exception as e:
        print("❌ Failed to open/parse JSON:", e)
        return

    # payload may be dict with "vulnerabilities" etc.
    if isinstance(payload, dict):
        if "vulnerabilities" in payload and isinstance(payload["vulnerabilities"], list):
            records = payload["vulnerabilities"]
        elif "vulnerabilities" not in payload and any(isinstance(v, dict) for v in payload.values()):
            # convert dict-of-objects -> list
            # but prefer top-level arrays under common keys
            for key in ("items","data","records","cves","vulnerabilities","exploits"):
                if key in payload and isinstance(payload[key], list):
                    records = payload[key]
                    break
            else:
                records = [payload]
        else:
            records = [payload]
    elif isinstance(payload, list):
        records = payload
    else:
        print("❌ Unsupported JSON root type")
        return

    print(f"Loaded {len(records)} records from {json_path}")

    # connect DB
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        conn.autocommit = False
        cur = conn.cursor()
        print("✅ Connected to PostgreSQL.")
    except Exception as e:
        print("❌ DB connection failed:", e)
        return

    # Insert SQL - update on conflict to keep latest
    insert_sql = """
    INSERT INTO "Storing-Threat-Data".cves (
        external_id, title, description, category, severity,
        cvss_score, cvss_vector, cwe_list, cwe_ids,
        vendors, products, affected_products_count,
        references_count, "references", tags,
        original_source_url, actual_url, source_name,
        published_date, last_updated_from_source,
        ingested_at, data_version, metadata
    ) VALUES (
        %(external_id)s, %(title)s, %(description)s, %(category)s, %(severity)s,
        %(cvss_score)s, %(cvss_vector)s, %(cwe_list)s, %(cwe_ids)s,
        %(vendors)s, %(products)s, %(affected_products_count)s,
        %(references_count)s, %(references)s::jsonb, %(tags)s,
        %(original_source_url)s, %(actual_url)s, %(source_name)s,
        %(published_date)s, %(last_updated_from_source)s,
        %(ingested_at)s, %(data_version)s, %(metadata)s::jsonb
    )
    ON CONFLICT (external_id) DO UPDATE
    SET
        title = EXCLUDED.title,
        description = EXCLUDED.description,
        category = EXCLUDED.category,
        severity = EXCLUDED.severity,
        cvss_score = EXCLUDED.cvss_score,
        cvss_vector = EXCLUDED.cvss_vector,
        cwe_list = EXCLUDED.cwe_list,
        cwe_ids = EXCLUDED.cwe_ids,
        vendors = EXCLUDED.vendors,
        products = EXCLUDED.products,
        affected_products_count = EXCLUDED.affected_products_count,
        references_count = EXCLUDED.references_count,
        "references" = EXCLUDED."references",
        tags = EXCLUDED.tags,
        original_source_url = EXCLUDED.original_source_url,
        actual_url = EXCLUDED.actual_url,
        source_name = EXCLUDED.source_name,
        published_date = EXCLUDED.published_date,
        last_updated_from_source = EXCLUDED.last_updated_from_source,
        ingested_at = EXCLUDED.ingested_at,
        data_version = EXCLUDED.data_version,
        metadata = EXCLUDED.metadata;
    """

    success = 0
    fail = 0

    for rec in records:
        try:
            if not isinstance(rec, dict):
                print("Skipping non-dict record")
                continue

            external_id = generate_external_id(rec)
            title = rec.get("vulnerabilityName") or rec.get("title") or external_id
            description = extract_description(rec)
            category = rec.get("category") or "vulnerability"

            # cwe
            cwe_list, cwe_ids = extract_cwes(rec)

            # vendors/products
            vendors, products = extract_vendors_products(rec)
            affected_count = max(1, len(products) or 1)

            # cvss & severity
            cvss_score, cvss_vector, severity_from_cvss = find_cvss_from_anywhere(rec)
            # if cvss_score is None, attempt inference based on description keywords
            if cvss_score is None:
                # basic heuristics
                desc = description.lower()
                if "remote code execution" in desc or "rce" in desc:
                    cvss_score = 9.8; severity_from_cvss = "CRITICAL"
                elif "privilege escalation" in desc or "authentication bypass" in desc:
                    cvss_score = 8.8; severity_from_cvss = "HIGH"
                elif "denial of service" in desc or "dos" in desc:
                    cvss_score = 7.5; severity_from_cvss = "HIGH"
                elif "sql injection" in desc or "injection" in desc:
                    cvss_score = 7.5; severity_from_cvss = "HIGH"
                elif "xss" in desc:
                    cvss_score = 6.5; severity_from_cvss = "MEDIUM"
                else:
                    cvss_score = 5.0; severity_from_cvss = severity_from_cvss or "UNKNOWN"

            cvss_vector = cvss_vector or (cvss_vector := cvss_vector if cvss_vector else "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N")
            severity = rec.get("severity") or severity_from_cvss or "UNKNOWN"

            # timestamps
            published_date = robust_isoparse(rec.get("dateAdded") or rec.get("published") or rec.get("published_date"))
            last_updated = robust_isoparse(rec.get("dueDate") or rec.get("lastModified") or rec.get("last_updated"))

            # references & urls
            references, refs_count, original_url_guess, actual_url_guess = extract_references_and_urls(rec)

            original_source_url = rec.get("original_source_url") or original_url_guess
            actual_url = rec.get("actual_url") or actual_url_guess
            source_name = rec.get("source_name") or "CISA KEV"

            tags = rec.get("tags") or ["CISA", "Known Exploited Vulnerability"]

            params = {
                "external_id": external_id,
                "title": title,
                "description": description,
                "category": category,
                "severity": severity,
                "cvss_score": float(cvss_score) if cvss_score is not None else None,
                "cvss_vector": cvss_vector,
                "cwe_list": cwe_list or [],
                "cwe_ids": cwe_ids or [],
                "vendors": vendors or [],
                "products": products or [],
                "affected_products_count": affected_count,
                "references_count": refs_count,
                "references": Json(references or []),
                "tags": tags,
                "original_source_url": original_source_url,
                "actual_url": actual_url,
                "source_name": source_name,
                "published_date": published_date,
                "last_updated_from_source": last_updated,
                "ingested_at": datetime.utcnow(),
                "data_version": str(rec.get("dataVersion") or rec.get("data_version") or "1.0"),
                "metadata": Json(rec)
            }

            cur.execute(insert_sql, params)
            success += 1
        except Exception as e:
            fail += 1
            print(f"❌ Failed record (external_id={rec.get('cveID') or rec.get('cveId') or 'unknown'}): {e}")
            # continue with next
    try:
        conn.commit()
    except Exception as e:
        print("Commit error:", e)
        conn.rollback()

    cur.close()
    conn.close()

    print(f"\nDone. Inserted/Updated: {success}, Failed: {fail}")

# === CLI ===
if __name__ == "__main__":
    path = sys.argv[1] if len(sys.argv) > 1 else "known_exploited_vulnerabilities.json"
    insert_from_json(path)
